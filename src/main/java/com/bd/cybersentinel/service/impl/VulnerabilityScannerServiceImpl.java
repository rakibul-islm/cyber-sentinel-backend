package com.bd.cybersentinel.service.impl;

import com.bd.cybersentinel.dto.req.VulnerabilityScannerReqDto;
import com.bd.cybersentinel.dto.res.VulnerabilityScannerResDTO;
import com.bd.cybersentinel.entity.VulnerabilityScannerLog;
import com.bd.cybersentinel.repository.VulnerabilityScannerRepo;
import com.bd.cybersentinel.service.VulnerabilityScannerService;
import com.bd.cybersentinel.service.exception.ServiceException;
import com.bd.cybersentinel.util.Response;
import org.modelmapper.ModelMapper;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.List;
import java.util.stream.Collectors;


@Service
public class VulnerabilityScannerServiceImpl extends AbstractBaseService<VulnerabilityScannerLog> implements VulnerabilityScannerService<VulnerabilityScannerResDTO, VulnerabilityScannerReqDto> {

	private final List<String> sqlPayloads = List.of(
			"' OR '1'='1",
			"' OR 1=1 --",
			"' OR 'a'='a",
			"'; DROP TABLE users; --"
	);
	private VulnerabilityScannerRepo vulnerabilityScannerRepo;

	VulnerabilityScannerServiceImpl(VulnerabilityScannerRepo vulnerabilityScannerRepo){
		super(vulnerabilityScannerRepo);
		this.vulnerabilityScannerRepo = vulnerabilityScannerRepo;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> testSqlInjection(String baseUrl) {
		for (String payload : sqlPayloads) {
			String testUrl = baseUrl + URLEncoder.encode(payload, StandardCharsets.UTF_8);
			try {
				HttpURLConnection connection = (HttpURLConnection) new URL(testUrl).openConnection();
				connection.setRequestMethod("GET");
				connection.setConnectTimeout(5000);
				connection.setReadTimeout(5000);
				String body = new String(connection.getInputStream().readAllBytes());

				// Basic detection logic (can be enhanced)
				if (body.toLowerCase().contains("sql syntax")
						|| body.toLowerCase().contains("mysql")
						|| body.toLowerCase().contains("psql")
						|| body.toLowerCase().contains("exception")) {
					createEntity(new VulnerabilityScannerLog().setIsVulnerable(true).setSearchUrl(baseUrl));

					return getSuccessResponse("‚ö†Ô∏è SQL Injection detected with payload: " + payload);
				}

			} catch (Exception e) {
				return getErrorResponse("‚ùå Error testing payload: " + payload + " - " + e.getMessage());
			}
		}
		createEntity(new VulnerabilityScannerLog().setIsVulnerable(false).setSearchUrl(baseUrl));

		return getSuccessResponse("‚úÖ No obvious SQL Injection detected.");
	}

	@Override
	public Response<VulnerabilityScannerResDTO> find(Long id) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> save(VulnerabilityScannerReqDto reqDto) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> update(VulnerabilityScannerReqDto reqDto) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> getAll(Pageable pageable, Boolean isPageable) throws ServiceException {
		if(Boolean.TRUE.equals(isPageable)) {
			Page<VulnerabilityScannerLog> page = vulnerabilityScannerRepo.findAllByDeleted(false, pageable);
			if(!page.hasContent()) return getErrorResponse("No log found in this system");

			return getSuccessResponse(
					"Found Vulnerability Scanner Logs",
					page.map(data -> new ModelMapper().map(data, VulnerabilityScannerResDTO.class))
			);
		}
		List<VulnerabilityScannerLog> list = vulnerabilityScannerRepo.findAllByDeleted(false);
		if(list == null || list.isEmpty()) return getErrorResponse("No log found in this system");

		return getSuccessResponse(
				"Found Vulnerability Scanner Logs",
				list.stream().map(data -> new ModelMapper().map(data, VulnerabilityScannerResDTO.class))
						.collect(Collectors.toList())
		);
	}

	@Override
	public Response<VulnerabilityScannerResDTO> delete(VulnerabilityScannerReqDto reqDto) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> remove(Long id) throws ServiceException {
		return null;
	}

	@Override
	public Response<VulnerabilityScannerResDTO> checkPasswordStrength(String password) {
		if (password == null || password.length() < 8) return getSuccessResponse("Weak: Password must be at least 8 characters long.");

		boolean hasUpper = false;
		boolean hasLower = false;
		boolean hasDigit = false;
		boolean hasSpecial = false;

		for (char ch : password.toCharArray()) {
			if (Character.isUpperCase(ch)) hasUpper = true;
			else if (Character.isLowerCase(ch)) hasLower = true;
			else if (Character.isDigit(ch)) hasDigit = true;
			else if ("!@#$%^&*()-_=+[]{}|;:'\",.<>?/`~".indexOf(ch) >= 0) hasSpecial = true;
		}

		if (!hasUpper) return getSuccessResponse("Weak: Must contain at least one uppercase letter.");
		if (!hasLower) return getSuccessResponse("Weak: Must contain at least one lowercase letter.");
		if (!hasDigit) return getSuccessResponse("Weak: Must contain at least one number.");
		if (!hasSpecial) return getSuccessResponse("Weak: Must contain at least one special character.");

		return getSuccessResponse("Strong Password üí™");
	}

	@Override
	public Response<VulnerabilityScannerResDTO> encode(String password) {
		String encoded = Base64.getEncoder().encodeToString(password.getBytes());

		return getSuccessResponse(encoded);
	}

	@Override
	public Response<VulnerabilityScannerResDTO> decode(String password) {
		String decoded = new String(Base64.getDecoder().decode(password));

		return getSuccessResponse(decoded);
	}
}
